From e6536360bd4496cee1f1bf2dfb0b11f6bdbbfd4b Mon Sep 17 00:00:00 2001
From: "Roderick W. Smith" <rodsmith@rodsbooks.com>
Date: Sun, 23 Sep 2012 21:29:10 +0200
Subject: [PATCH] add support for a new Linux-specific GPT partition type code

* NEWS: Describe the new Linux-specific partition type code
and the new msftres flag that can be used to override this type
code, should it be necessary.
* doc/parted.texi: Describe of the new msftres flag.
* include/parted/disk.in.h [_PedPartitionFlag]: Add
PED_PARTITION_MSFT_DATA.
* libparted/disk.c: Add check for PED_PARTITION_MSFT_DATA, with
return of "msftdata", to ped_partition_flag_get_name()
* libparted/labels/gpt.c (PARTITION_LINUX_DATA_GUID): Define.
[_GPTPartitionData]: New member, "int msftdata".
(_parse_part_entry): Set the msftdata flag if and only if the
PARTITION_BASIC_DATA_GUID type code is in use;
(gpt_partition_new): Use the PARTITION_LINUX_DATA_GUID
type as the default type code
(gpt_partition_set_system): Set the PARTITION_BASIC_DATA_GUID type
code on partitions on which the msftdata flag is set and set
PARTITION_LINUX_DATA_GUID as the type by default.
Clear the msftdata flag in most tests in gpt_partition_set_flag()
(gpt_partition_set_flag): Add test for PED_PARTITION_MSFT_DATA, which
sets msftdata and other flags appropriately
(gpt_partition_get_flag): Add test for the PED_PARTITION_MSFT_DATA
item that returns the status of the msftdata flag
(gpt_partition_is_flag_available): Add test for
PED_PARTITION_MSFT_DATA item to
* tests/t0220-gpt-msftres.sh: Accommodate the fact that now,
partition table listings include "msftdata" for file systems
of type NTFS and FAT*.
For more discussion and justification, see
http://thread.gmane.org/gmane.comp.gnu.parted.bugs/10456
---
 NEWS                       |   19 +++++++++++++++++++
 doc/parted.texi            |   16 +++++++++++++++-
 include/parted/disk.in.h   |    5 +++--
 libparted/disk.c           |    2 ++
 libparted/labels/gpt.c     |   45 ++++++++++++++++++++++++++++++++++++++++++--
 tests/t0220-gpt-msftres.sh |    3 ++-
 6 files changed, 84 insertions(+), 6 deletions(-)

--- a/NEWS
+++ b/NEWS
@@ -44,6 +44,25 @@
   sector support being "HIGHLY EXPERIMENTAL".  It seems to have matured
   enough to be usable at least with GPT and MSDOS partition tables.
 
+** Changes in behavior
+
+  Added new Linux-specific partition GUID type code
+  (0FC63DAF-8483-4772-8E79-3D69D8477DE4) for Linux filesystem data on GPT
+  disks.  This type code is now assigned as the default partition type code
+  for new partitions holding Linux filesystems.
+
+  Added new "msftdata" flag to identify partitions holding NTFS or FAT
+  filesystems on GPT disks.  This flag corresponds to a GPT type code of
+  EBD0A0A2-B9E5-4433-87C0-68B6B72699C7 ("Microsoft Basic Data").  Since
+  Linux filesystem partitions formerly used this type code, this flag may
+  optionally be set on Linux partitions to make the partition table type
+  codes match former configurations in case the new Linux filesystem type
+  code causes problems with some utility.  Note that this flag cannot be
+  removed from NTFS or FAT partitions within parted except by setting a
+  competing flag, such as "boot" (which sets the type code used by EFI
+  System partitions) or "msftres" (which sets the "Microsoft Reserved" type
+  code).
+
 
 * Noteworthy changes in release 2.2 (2010-02-26) [stable]
 
--- a/doc/parted.texi
+++ b/doc/parted.texi
@@ -1061,6 +1061,20 @@
 For PC98 disk labels, all ext2 partitions must be bootable (this is
 enforced by Parted).
 
+@item msftdata
+(GPT) - This flag identifies partitions that contain Microsoft filesystems
+(NTFS or FAT).  It may optionally be set on Linux filesystems to mimic the
+type of configuration created by parted 3.0 and earlier, in which a
+separate Linux filesystem type code was not available on GPT disks.  This
+flag can only be removed within parted by replacing it with a competing
+flag, such as boot or msftres.
+
+@item msftres
+(GPT) - This flag identifies a "Microsoft Reserved" partition, which is
+used by Windows on GPT disks.  Note that this flag should not normally be
+set on Windows filesystem partitions (those that contain NTFS or FAT
+filesystems).
+
 @item lba
 (MS-DOS) - this flag can be enabled to tell MS DOS, MS Windows 9x and
 MS Windows ME based operating systems to use Linear (LBA) mode.
--- a/libparted/disk.c
+++ b/libparted/disk.c
@@ -2439,6 +2439,8 @@
 		return N_("prep");
 	case PED_PARTITION_MSFT_RESERVED:
 		return N_("msftres");
+	case PED_PARTITION_MSFT_DATA:
+		return N_("msftdata");
         case PED_PARTITION_APPLE_TV_RECOVERY:
                 return N_("atvrecv");
         case PED_PARTITION_DIAG:
--- a/libparted/labels/gpt.c
+++ b/libparted/labels/gpt.c
@@ -126,6 +126,10 @@
     ((efi_guid_t) { PED_CPU_TO_LE32 (0x0657fd6d), PED_CPU_TO_LE16 (0xa4ab), \
                     PED_CPU_TO_LE16 (0x43c4), 0x84, 0xe5, \
                     { 0x09, 0x33, 0xc8, 0x4b, 0x4f, 0x4f }})
+#define PARTITION_LINUX_DATA_GUID \
+    ((efi_guid_t) { PED_CPU_TO_LE32 (0x0FC63DAF), PED_CPU_TO_LE16 (0x8483), \
+                    PED_CPU_TO_LE16 (0x4772), 0x8E, 0x79, \
+                    { 0x3D, 0x69, 0xD8, 0x47, 0x7D, 0xE4 }})
 #define PARTITION_LVM_GUID \
     ((efi_guid_t) { PED_CPU_TO_LE32 (0xe6d6d379), PED_CPU_TO_LE16 (0xf507), \
                     PED_CPU_TO_LE16 (0x44c2), 0xa2, 0x3c, \
@@ -287,6 +291,7 @@
   int hp_service;
   int hidden;
   int msftres;
+  int msftdata;
   int atvrecv;
   int msftrecv;
   int legacy_boot;
@@ -1048,6 +1053,7 @@
   gpt_part_data->lvm = gpt_part_data->raid
     = gpt_part_data->boot = gpt_part_data->hp_service
     = gpt_part_data->hidden = gpt_part_data->msftres
+    = gpt_part_data->msftdata
     = gpt_part_data->msftrecv
     = gpt_part_data->legacy_boot
     = gpt_part_data->bios_grub = gpt_part_data->atvrecv = 0;
@@ -1069,6 +1075,8 @@
     gpt_part_data->hp_service = 1;
   else if (!guid_cmp (gpt_part_data->type, PARTITION_MSFT_RESERVED_GUID))
     gpt_part_data->msftres = 1;
+  else if (!guid_cmp (gpt_part_data->type, PARTITION_BASIC_DATA_GUID))
+    gpt_part_data->msftdata = 1;
   else if (!guid_cmp (gpt_part_data->type, PARTITION_MSFT_RECOVERY))
     gpt_part_data->msftrecv = 1;
   else if (!guid_cmp (gpt_part_data->type, PARTITION_APPLE_TV_RECOVERY_GUID))
@@ -1699,7 +1707,7 @@
   if (!gpt_part_data)
     goto error_free_part;
 
-  gpt_part_data->type = PARTITION_BASIC_DATA_GUID;
+  gpt_part_data->type = PARTITION_LINUX_DATA_GUID;
   gpt_part_data->lvm = 0;
   gpt_part_data->raid = 0;
   gpt_part_data->boot = 0;
@@ -1707,6 +1715,7 @@
   gpt_part_data->hp_service = 0;
   gpt_part_data->hidden = 0;
   gpt_part_data->msftres = 0;
+  gpt_part_data->msftdata = 0;
   gpt_part_data->msftrecv = 0;
   gpt_part_data->atvrecv = 0;
   gpt_part_data->legacy_boot = 0;
@@ -1803,6 +1812,11 @@
       gpt_part_data->type = PARTITION_MSFT_RESERVED_GUID;
       return 1;
     }
+  if (gpt_part_data->msftdata)
+    {
+      gpt_part_data->type = PARTITION_BASIC_DATA_GUID;
+      return 1;
+    }
   if (gpt_part_data->msftrecv)
     {
       gpt_part_data->type = PARTITION_MSFT_RECOVERY;
@@ -1839,7 +1853,7 @@
         }
     }
 
-  gpt_part_data->type = PARTITION_BASIC_DATA_GUID;
+  gpt_part_data->type = PARTITION_LINUX_DATA_GUID;
   return 1;
 }
 
@@ -1917,6 +1931,7 @@
           = gpt_part_data->bios_grub
           = gpt_part_data->hp_service
           = gpt_part_data->msftres
+          = gpt_part_data->msftdata
           = gpt_part_data->msftrecv
           = gpt_part_data->atvrecv = 0;
       return gpt_partition_set_system (part, part->fs_type);
@@ -1928,6 +1943,7 @@
           = gpt_part_data->boot
           = gpt_part_data->hp_service
           = gpt_part_data->msftres
+          = gpt_part_data->msftdata
           = gpt_part_data->msftrecv
           = gpt_part_data->atvrecv = 0;
       return gpt_partition_set_system (part, part->fs_type);
@@ -1939,6 +1955,7 @@
           = gpt_part_data->bios_grub
           = gpt_part_data->hp_service
           = gpt_part_data->msftres
+          = gpt_part_data->msftdata
           = gpt_part_data->msftrecv
           = gpt_part_data->atvrecv = 0;
       return gpt_partition_set_system (part, part->fs_type);
@@ -1950,6 +1967,7 @@
           = gpt_part_data->bios_grub
           = gpt_part_data->hp_service
           = gpt_part_data->msftres
+          = gpt_part_data->msftdata
           = gpt_part_data->msftrecv
           = gpt_part_data->atvrecv = 0;
       return gpt_partition_set_system (part, part->fs_type);
@@ -1961,6 +1979,7 @@
           = gpt_part_data->lvm
           = gpt_part_data->bios_grub
           = gpt_part_data->msftres
+          = gpt_part_data->msftdata
           = gpt_part_data->msftrecv
           = gpt_part_data->atvrecv = 0;
       return gpt_partition_set_system (part, part->fs_type);
@@ -1972,8 +1991,26 @@
           = gpt_part_data->lvm
           = gpt_part_data->bios_grub
           = gpt_part_data->hp_service
+          = gpt_part_data->msftdata
+          = gpt_part_data->msftrecv
+          = gpt_part_data->atvrecv = 0;
+      return gpt_partition_set_system (part, part->fs_type);
+    case PED_PARTITION_MSFT_DATA:
+      gpt_part_data->msftres = state;
+      if (state) {
+        gpt_part_data->boot
+          = gpt_part_data->raid
+          = gpt_part_data->lvm
+          = gpt_part_data->bios_grub
+          = gpt_part_data->hp_service
+          = gpt_part_data->msftres
+          = gpt_part_data->msftdata
           = gpt_part_data->msftrecv
           = gpt_part_data->atvrecv = 0;
+        gpt_part_data->msftdata = 1;
+      } else {
+        gpt_part_data->msftdata = 0;
+      }
       return gpt_partition_set_system (part, part->fs_type);
     case PED_PARTITION_DIAG:
       gpt_part_data->msftrecv = state;
@@ -1983,6 +2020,7 @@
           = gpt_part_data->lvm
           = gpt_part_data->bios_grub
           = gpt_part_data->hp_service
+          = gpt_part_data->msftdata
           = gpt_part_data->msftres
           = gpt_part_data->atvrecv = 0;
       return gpt_partition_set_system (part, part->fs_type);
@@ -1995,6 +2033,7 @@
           = gpt_part_data->bios_grub
           = gpt_part_data->hp_service
           = gpt_part_data->msftres
+          = gpt_part_data->msftdata
           = gpt_part_data->msftrecv = 0;
       return gpt_partition_set_system (part, part->fs_type);
     case PED_PARTITION_HIDDEN:
@@ -2033,6 +2072,8 @@
       return gpt_part_data->hp_service;
     case PED_PARTITION_MSFT_RESERVED:
       return gpt_part_data->msftres;
+    case PED_PARTITION_MSFT_DATA:
+      return gpt_part_data->msftdata;
     case PED_PARTITION_DIAG:
       return gpt_part_data->msftrecv;
     case PED_PARTITION_APPLE_TV_RECOVERY:
@@ -2062,6 +2103,7 @@
     case PED_PARTITION_BIOS_GRUB:
     case PED_PARTITION_HPSERVICE:
     case PED_PARTITION_MSFT_RESERVED:
+    case PED_PARTITION_MSFT_DATA:
     case PED_PARTITION_DIAG:
     case PED_PARTITION_APPLE_TV_RECOVERY:
     case PED_PARTITION_HIDDEN:
--- a/tests/t0220-gpt-msftres.sh
+++ b/tests/t0220-gpt-msftres.sh
@@ -60,7 +60,8 @@
 rm -f out
 for type in $fs_types; do
   end=$(expr $start + $part_size - 1)
-  echo "$i:${start}s:${end}s:${part_size}s::$type:;" >> exp || fail=1
+  case $type in fat*|NTFS) flag=msftdata;; *) flag=;; esac
+  echo "$i:${start}s:${end}s:${part_size}s::$type:$flag;" >> exp || fail=1
   parted -s $dev mkpart primary $type ${start}s ${end}s >> out 2>&1 || fail=1
   parted -s $dev name $i $type >> out 2>&1 || fail=1
   start=$(expr $end + 1)
--- a/include/parted/disk.h
+++ b/include/parted/disk.h
@@ -70,10 +70,11 @@
         PED_PARTITION_BIOS_GRUB=12,
         PED_PARTITION_APPLE_TV_RECOVERY=13,
         PED_PARTITION_DIAG=14,
-        PED_PARTITION_LEGACY_BOOT=15
+	PED_PARTITION_LEGACY_BOOT=15,
+	PED_PARTITION_MSFT_DATA=16
 };
 #define PED_PARTITION_FIRST_FLAG        PED_PARTITION_BOOT
-#define PED_PARTITION_LAST_FLAG         PED_PARTITION_LEGACY_BOOT
+#define PED_PARTITION_LAST_FLAG         PED_PARTITION_MSFT_DATA
 
 enum _PedDiskTypeFeature {
         PED_DISK_TYPE_EXTENDED=1,       /**< supports extended partitions */
