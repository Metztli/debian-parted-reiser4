From: Phillip Susi <psusi@cfl.rr.com>
Subject: refactor device-mapper partition sync code
Forwarded: Yes
Description: The device-mapper partition sync code was still using the remove
 all partitions, then add new partitions method.  Refactor to use the same
 algorithm as regular disks: try to remove all, and ignore any that could not
 be removed but have not changed.
--- a/libparted/arch/linux.c
+++ b/libparted/arch/linux.c
@@ -269,6 +269,16 @@
 static int _partition_is_mounted_by_path (const char* path);
 static int
 _dm_is_part (const char *path);
+static int
+_dm_add_partition (PedDisk* disk, const PedPartition* part);
+static int
+_dm_remove_partition(PedDisk* disk, int partno);
+static bool
+_dm_get_partition_start_and_length(PedPartition const *part,
+                                   unsigned long long *start,
+                                   unsigned long long *length);
+static int
+_is_dmraid_device (char* devpath);
 
 
 static int
@@ -2225,10 +2235,39 @@
                 _probe_proc_partitions ();
 }
 
+static char *dm_canonical_path (PedDevice *dev)
+{
+        char*           dev_name = NULL;
+        LinuxSpecific*  arch_specific = LINUX_SPECIFIC (dev);
+
+        /* Get map name from devicemapper */
+        struct dm_task *task = dm_task_create (DM_DEVICE_INFO);
+        if (!task)
+                goto err;
+        if (!dm_task_set_major_minor (task, arch_specific->major,
+                                      arch_specific->minor, 0))
+                goto err;
+        if (!dm_task_run(task))
+                goto err;
+        dev_name = ped_malloc (strlen (dm_task_get_name (task)) +
+                               strlen ("/dev/mapper/") + 1);
+        strcpy (dev_name, "/dev/mapper/");
+        strcat (dev_name, dm_task_get_name (task));
+        /* Caution: dm_task_destroy frees dev_name.  */
+        dm_task_destroy (task);
+        return dev_name;
+err:
+        return NULL;
+}
+
 static char*
 _device_get_part_path (PedDevice* dev, int num)
 {
-        int             path_len = strlen (dev->path);
+        char*           devpath;
+        if (dev->type == PED_DEVICE_DM)
+                devpath = dm_canonical_path (dev);
+        else devpath = dev->path;
+        int             path_len = strlen (devpath);
         int             result_len = path_len + 16;
         char*           result;
 
@@ -2239,18 +2278,19 @@
         /* Check for devfs-style /disc => /partN transformation
            unconditionally; the system might be using udev with devfs rules,
            and if not the test is harmless. */
-        if (!strcmp (dev->path + path_len - 5, "/disc")) {
+        if (!strcmp (devpath + path_len - 5, "/disc")) {
                 /* replace /disc with /path%d */
-                strcpy (result, dev->path);
+                strcpy (result, devpath);
                 snprintf (result + path_len - 5, 16, "/part%d", num);
         } else if (dev->type == PED_DEVICE_DAC960
                         || dev->type == PED_DEVICE_CPQARRAY
                         || dev->type == PED_DEVICE_ATARAID
-                        || isdigit (dev->path[path_len - 1]))
-                snprintf (result, result_len, "%sp%d", dev->path, num);
+                        || isdigit (devpath[path_len - 1]))
+                snprintf (result, result_len, "%sp%d", devpath, num);
         else
-                snprintf (result, result_len, "%s%d", dev->path, num);
-
+                snprintf (result, result_len, "%s%d", devpath, num);
+        if (dev->type == PED_DEVICE_DM)
+                free (devpath);
         return result;
 }
 
@@ -2537,6 +2577,9 @@
         FILE*       fp;
         bool        ok;
 
+        if (dev->type == PED_DEVICE_DM)
+                return MAX_NUM_PARTS;
+
         r = snprintf(path, sizeof(path), "/sys/block/%s/range",
                      last_component(dev->path));
         if (r < 0 || r >= sizeof(path))
@@ -2574,6 +2617,23 @@
         PED_ASSERT(disk->dev != NULL, return 0);
         int lpn;
 
+        int (*add_partition)(PedDisk* disk, const PedPartition *part);
+        int (*remove_partition)(PedDisk* disk, int partno);
+        bool (*get_partition_start_and_length)(PedPartition const *part,
+                                               unsigned long long *start,
+                                               unsigned long long *length);
+
+
+        if (disk->dev->type == PED_DEVICE_DM) {
+                add_partition = _dm_add_partition;
+                remove_partition = _dm_remove_partition;
+                get_partition_start_and_length = _dm_get_partition_start_and_length;
+        } else {
+                add_partition = _blkpg_add_partition;
+                remove_partition = _blkpg_remove_partition;
+                get_partition_start_and_length = _kernel_get_partition_start_and_length;
+        }
+
         /* lpn = largest partition number. */
         if (ped_disk_get_max_supported_partition_count(disk, &lpn))
                 lpn = PED_MIN(lpn, _device_get_partition_range(disk->dev));
@@ -2607,7 +2667,7 @@
             int j;
             for (j = 0; j < lpn; j++) {
                 if (!ok[j]) {
-                    ok[j] = _blkpg_remove_partition (disk, j + 1);
+                    ok[j] = remove_partition (disk, j + 1);
                     errnums[j] = errno;
                     if (!ok[j] && errnums[j] == EBUSY)
                         busy = true;
@@ -2624,9 +2684,9 @@
                                 unsigned long long length;
                                 unsigned long long start;
                                 /* get start and length of existing partition */
-                                if (!_kernel_get_partition_start_and_length(part,
-                                                                &start, &length))
-                                        goto cleanup;
+                                if (!get_partition_start_and_length(part,
+                                                                    &start, &length))
+                                          goto cleanup;
                                 if (start == part->geom.start
 				    && length == part->geom.length)
                                         ok[i - 1] = 1;
@@ -2638,7 +2698,7 @@
                         }
 
                         /* add the (possibly modified or new) partition */
-                        if (!_blkpg_add_partition (disk, part)) {
+                        if (!add_partition (disk, part)) {
                                 ped_exception_throw (
                                         PED_EXCEPTION_ERROR,
                                         PED_EXCEPTION_RETRY_CANCEL,
@@ -2686,24 +2746,34 @@
 
 #ifdef ENABLE_DEVICE_MAPPER
 static int
-_dm_remove_map_name(char *name)
+_dm_remove_partition(PedDisk* disk, int partno)
 {
         struct dm_task  *task = NULL;
         int             rc;
+        char            *part_name = _device_get_part_path (disk->dev, partno);
 
+        int fd = open (part_name, O_RDONLY | O_EXCL);
+        if (fd == -1) {
+                if (errno == ENOENT)
+                        errno = ENXIO; /* nothing to remove, device already doesn't exist */
+                free (part_name);
+                return 0;
+        }
+        close (fd);
         task = dm_task_create(DM_DEVICE_REMOVE);
-        if (!task)
-                return 1;
-
-        dm_task_set_name (task, name);
-
+        if (!task) {
+                free (part_name);
+                return 0;
+        }
+        dm_task_set_name (task, part_name);
         rc = dm_task_run(task);
         dm_task_update_nodes();
         dm_task_destroy(task);
+        free (part_name);
         if (!rc)
-                return 1;
+                return 0;
 
-        return 0;
+        return 1;
 }
 
 /* We consider a dm device that is a linear mapping with a  *
@@ -2757,65 +2827,38 @@
         return rc;
 }
 
-static int
-_dm_remove_parts (PedDevice* dev)
+static bool
+_dm_get_partition_start_and_length(PedPartition const *part,
+                                   unsigned long long *start,
+                                   unsigned long long *length)
 {
-        struct dm_task*         task = NULL;
-        struct dm_info*         info = alloca(sizeof *info);
-        struct dm_names*        names = NULL;
-        unsigned int            next = 0;
-        int                     rc;
-        LinuxSpecific*          arch_specific = LINUX_SPECIFIC (dev);
-
-        task = dm_task_create(DM_DEVICE_LIST);
-        if (!task)
-                goto err;
-
-        if (!dm_task_set_major_minor (task, arch_specific->major,
-                                      arch_specific->minor, 0))
-                goto err;
+        struct dm_task* task = NULL;
+        int             rc = 0;
+        char *target_type = NULL;
+        char *params;
+        char *path;
+        int major, minor;
 
+        if (!(task = dm_task_create(DM_DEVICE_TABLE)))
+                return 0;
+        path = _device_get_part_path (part->disk->dev, part->num);
+        PED_ASSERT(path, return false);
+        dm_task_set_name(task, path);
         if (!dm_task_run(task))
                 goto err;
-
-        memset(info, '\0', sizeof *info);
-        dm_task_get_info(task, info);
-        if (!info->exists)
-                goto err;
-
-        names = dm_task_get_names(task);
-        if (!names)
+        dm_get_next_target(task, NULL, (uint64_t *)start, (uint64_t *)length, &target_type, &params);
+        if (sscanf (params, "%d:%d %Ld", &major, &minor, start) != 3)
                 goto err;
-
-        rc = 0;
-        do {
-                names = (void *) ((char *) names + next);
-
-                if (_dm_is_part(info, names->name))
-                        rc += _dm_remove_map_name(names->name);
-
-                next = names->next;
-        } while (next);
-
-        dm_task_update_nodes();
-        dm_task_destroy(task);
-        task = NULL;
-
-        if (!rc)
-                return 1;
+        rc = 1;
 err:
-        if (task)
-                dm_task_destroy(task);
-        ped_exception_throw (PED_EXCEPTION_WARNING, PED_EXCEPTION_IGNORE,
-                _("parted was unable to re-read the partition "
-                  "table on %s (%s).  This means Linux won't know "
-                  "anything about the modifications you made. "),
-                dev->path, strerror (errno));
-        return 0;
+        free (path);
+        dm_task_destroy(task);
+        return rc;
 }
 
+
 static int
-_dm_add_partition (PedDisk* disk, PedPartition* part)
+_dm_add_partition (PedDisk* disk, const PedPartition* part)
 {
         char*           vol_name = NULL;
         const char*     dev_name = NULL;
@@ -2868,7 +2911,7 @@
                 free(vol_name);
                 return 1;
         } else {
-                _dm_remove_map_name(vol_name);
+                _dm_remove_partition (disk, part->num);
         }
 err:
         dm_task_update_nodes();
@@ -2878,34 +2921,6 @@
         free (vol_name);
         return 0;
 }
-
-static int
-_dm_reread_part_table (PedDisk* disk)
-{
-        int largest_partnum = ped_disk_get_last_partition_num (disk);
-        if (largest_partnum <= 0)
-          return 1;
-
-        int     rc = 1;
-        int     last = PED_MIN (largest_partnum, 16);
-        int     i;
-
-        sync();
-        if (!_dm_remove_parts(disk->dev))
-                rc = 0;
-
-        for (i = 1; i <= last; i++) {
-                PedPartition*      part;
-
-                part = ped_disk_get_partition (disk, i);
-                if (!part)
-                        continue;
-
-                if (!_dm_add_partition (disk, part))
-                        rc = 0;
-        }
-        return rc;
-}
 #endif
 
 static int
@@ -2928,10 +2943,6 @@
         if (!_has_partitions (disk))
                 return 1;
 
-#ifdef ENABLE_DEVICE_MAPPER
-        if (disk->dev->type == PED_DEVICE_DM)
-                return _dm_reread_part_table (disk);
-#endif
         if (disk->dev->type != PED_DEVICE_FILE) {
                 /* The ioctl() command BLKPG_ADD_PARTITION does not notify
                  * the devfs system; consequently, /proc/partitions will not
