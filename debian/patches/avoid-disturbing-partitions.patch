Author: Phillip Susi <psusi@ubuntu.com>
Description: The partition sync logic was first removing all
 partitions, then trying to re-add them.  This resulted in many
 udev events triggering annoying behavior like auto mounting.
 Refactor the code to avoid removing and re-adding unmodified
 partitions.

--- a/libparted/arch/linux.c
+++ b/libparted/arch/linux.c
@@ -2705,60 +2705,52 @@
         int *errnums = ped_malloc(sizeof(int) * lpn);
         if (!errnums)
                 goto cleanup;
-
-        /* Attempt to remove each and every partition, retrying for
-           up to max_sleep_seconds upon any failure due to EBUSY. */
-        unsigned int sleep_microseconds = 10000;
-        unsigned int max_sleep_seconds = 1;
-        unsigned int n_sleep = (max_sleep_seconds
-                                * 1000000 / sleep_microseconds);
         int i;
-        for (i = 0; i < n_sleep; i++) {
-	    if (i)
-		usleep (sleep_microseconds);
-            bool busy = false;
-            int j;
-            for (j = 0; j < lpn; j++) {
-                if (!ok[j]) {
-                    ok[j] = remove_partition (disk, j + 1);
-                    errnums[j] = errno;
-                    if (!ok[j] && errnums[j] == EBUSY)
-                        busy = true;
-                }
-            }
-            if (!busy)
-                break;
-        }
-
         for (i = 1; i <= lpn; i++) {
                 PedPartition *part = ped_disk_get_partition (disk, i);
                 if (part) {
-                        if (!ok[i - 1] && errnums[i - 1] == EBUSY) {
-                                unsigned long long length;
-                                unsigned long long start;
-                                /* get start and length of existing partition */
-                                if (!get_partition_start_and_length(part,
-                                                                    &start, &length))
-                                          goto cleanup;
-                                if (start == part->geom.start
-				    && length == part->geom.length)
-                                        ok[i - 1] = 1;
+                        unsigned long long length;
+                        unsigned long long start;
+                        /* get start and length of existing partition */
+                        if (!get_partition_start_and_length(part,
+                                                            &start, &length))
+                                goto remove_partition;
+                        if (start == part->geom.start
+                            && length == part->geom.length)
+                        {
+                                ok[i - 1] = 1;
+                                continue;
+                        }
 #ifdef BLKPG_RESIZE_PARTITION
-                                if (start == part->geom.start
-                                    && length != part->geom.length)
+                        if (start == part->geom.start
+                            && length != part->geom.length)
+                        {
+                                /* try to resize */
+                                if (_blkpg_resize_partition (disk, part))
                                 {
-                                        /* try to resize */
-                                        if (_blkpg_resize_partition (disk, part))
-                                                ok[i - 1] = 1;
+                                        ok[i - 1] = 1;
+                                        continue;
                                 }
-#endif
-                                /* If the new partition is unchanged and the
-				   existing one was not removed because it was
-				   in use, then reset the error flag and do not
-				   try to add it since it is already there.  */
-                                continue;
                         }
-
+#endif
+                }
+                /* Attempt to remove the partition, retrying for
+                   up to max_sleep_seconds upon any failure due to EBUSY. */
+                unsigned int sleep_microseconds = 10000;
+                unsigned int max_sleep_seconds = 1;
+                unsigned int n_sleep = (max_sleep_seconds
+                                        * 1000000 / sleep_microseconds);
+	remove_partition:
+                do {
+                        ok[i-1] = remove_partition (disk, i);
+                        errnums[i-1] = errno;
+                        if (ok[i-1] || errnums[i-1] != EBUSY)
+                                break;
+                        usleep (sleep_microseconds);
+                } while (n_sleep--);
+                if (!ok[i-1] && errnums[i-1] == ENXIO)
+                        ok[i-1] = 1; /* it already doesn't exist */
+                if (part && ok[i-1]) {
                         /* add the (possibly modified or new) partition */
                         if (!add_partition (disk, part)) {
                                 ped_exception_throw (
@@ -2768,6 +2760,7 @@
                                         i, strerror (errno));
                                 goto cleanup;
                         }
+			ok[i-1] = 1;
                 }
         }
 
