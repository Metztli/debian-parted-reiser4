From 261305840904f1dea49b83b9170b14f0b049f317 Mon Sep 17 00:00:00 2001
From: Phillip Susi <psusi@ubuntu.com>
Date: Fri, 28 Mar 2014 17:10:02 +0000
Subject: Backport some changes to allow use of partitionable loop devices

Upstream has switched to using the newer sysfs attribute "ext_range"
instead of "range" to read the maximum supported partitions of a device.
This allows loop devices to be partitioned even without using the kernel
max_part argument, as well as support for more than 16 partitions.  Also
added new PED_DEVICE_LOOP device type instead of pretending loop devices
are files.

Forwarded: no

Patch-Name: loop-partitions.patch
---
 include/parted/device.h |   3 +-
 libparted/arch/linux.c  | 125 ++++++++++++++++++++++++++++++++++++++----------
 parted/parted.c         |   2 +-
 3 files changed, 104 insertions(+), 26 deletions(-)

diff --git a/include/parted/device.h b/include/parted/device.h
index 0634465..b94765c 100644
--- a/include/parted/device.h
+++ b/include/parted/device.h
@@ -48,7 +48,8 @@ typedef enum {
         PED_DEVICE_SDMMC        = 14,
         PED_DEVICE_VIRTBLK      = 15,
         PED_DEVICE_AOE          = 16,
-        PED_DEVICE_MD           = 17
+        PED_DEVICE_MD           = 17,
+        PED_DEVICE_LOOP         = 18
 } PedDeviceType;
 
 typedef struct _PedDevice PedDevice;
diff --git a/libparted/arch/linux.c b/libparted/arch/linux.c
index be7e95d..ecd0139 100644
--- a/libparted/arch/linux.c
+++ b/libparted/arch/linux.c
@@ -574,7 +574,7 @@ _device_probe_type (PedDevice* dev)
         } else if (_is_virtblk_major(dev_major)) {
                 dev->type = PED_DEVICE_VIRTBLK;
         } else if (dev_major == LOOP_MAJOR) {
-                dev->type = PED_DEVICE_FILE;
+                dev->type = PED_DEVICE_LOOP;
         } else if (dev_major == MD_MAJOR) {
                 dev->type = PED_DEVICE_MD;
         } else {
@@ -1395,6 +1395,11 @@ linux_new (const char* path)
                         goto error_free_arch_specific;
                 break;
 
+        case PED_DEVICE_LOOP:
+                if (!init_generic (dev, _("Loopback device")))
+                        goto error_free_arch_specific;
+                break;
+
         default:
                 ped_exception_throw (PED_EXCEPTION_NO_FEATURE,
                                 PED_EXCEPTION_CANCEL,
@@ -2388,6 +2393,95 @@ _blkpg_remove_partition (PedDisk* disk, int n)
                                     BLKPG_DEL_PARTITION);
 }
 
+/* Read the unsigned long long from /sys/block/DEV_BASE/PART_BASE/ENTRY
+   and set *VAL to that value, where DEV_BASE is the last component of path to
+   block device corresponding to PART and PART_BASE is the sysfs name of PART.
+   Upon success, return true. Otherwise, return false. */
+static bool
+_sysfs_ull_entry_from_part(PedPartition const* part, const char *entry,
+                           unsigned long long *val)
+{
+        char path[128];
+        char *part_name = linux_partition_get_path(part);
+        if (!part_name)
+                return false;
+
+        int r = snprintf(path, sizeof(path), "/sys/block/%s/%s/%s",
+                last_component(part->disk->dev->path),
+                last_component(part_name), entry);
+        free(part_name);
+        if (r < 0 || r >= sizeof(path))
+                return false;
+
+        FILE *fp = fopen(path, "r");
+        if (!fp)
+                return false;
+
+        bool ok = fscanf(fp, "%llu", val) == 1;
+        fclose(fp);
+
+        return ok;
+}
+
+
+/* Get the starting sector and length of a partition PART within a block device
+   Use blkpg if available, then check sysfs and then use HDIO_GETGEO and
+   BLKGETSIZE64 ioctls as fallback.  Upon success, return true.  Otherwise,
+   return false. */
+static bool
+_kernel_get_partition_start_and_length(PedPartition const *part,
+                                       unsigned long long *start,
+                                       unsigned long long *length)
+{
+        PED_ASSERT(part, return false);
+        PED_ASSERT(start, return false);
+        PED_ASSERT(length, return false);
+
+        char *dev_name = linux_partition_get_path (part);
+        if (!dev_name)
+                return false;
+
+        int ok = _sysfs_ull_entry_from_part (part, "start", start);
+        if (!ok) {
+                struct hd_geometry geom;
+                int dev_fd = open (dev_name, O_RDONLY);
+                if (dev_fd != -1 && ioctl (dev_fd, HDIO_GETGEO, &geom)) {
+                        *start = geom.start;
+                        ok = true;
+                } else {
+                        if (dev_fd != -1)
+                                close(dev_fd);
+                        free (dev_name);
+                        return false;
+                }
+        }
+        *start = (*start * 512) / part->disk->dev->sector_size;
+        ok = _sysfs_ull_entry_from_part (part, "size", length);
+
+        int fd;
+        if (!ok) {
+                fd = open (dev_name, O_RDONLY);
+                if (fd != -1 && ioctl (fd, BLKGETSIZE64, length))
+                        ok = true;
+        } else {
+                fd = -1;
+                *length *= 512;
+        }
+        *length /= part->disk->dev->sector_size;
+        if (fd != -1)
+                close (fd);
+
+        if (!ok)
+                ped_exception_throw (
+                        PED_EXCEPTION_BUG,
+                        PED_EXCEPTION_CANCEL,
+                        _("Unable to determine the start and length of %s."),
+                        dev_name);
+        free (dev_name);
+        return ok;
+}
+
+
 /*
  * The number of partitions that a device can have depends on the kernel.
  * If we don't find this value in /sys/block/DEV/range, we will use our own
@@ -2482,33 +2576,16 @@ _disk_sync_part_table (PedDisk* disk)
         }
 
         for (i = 1; i <= lpn; i++) {
-                const PedPartition *part = ped_disk_get_partition (disk, i);
+                PedPartition *part = ped_disk_get_partition (disk, i);
                 if (part) {
                         if (!ok[i - 1] && errnums[i - 1] == EBUSY) {
-                                struct hd_geometry geom;
-                                unsigned long long length = 0;
+                                unsigned long long length;
+                                unsigned long long start;
                                 /* get start and length of existing partition */
-                                char *dev_name = _device_get_part_path (disk->dev, i);
-                                if (!dev_name)
-                                        goto cleanup;
-                                int fd = open (dev_name, O_RDONLY);
-                                if (fd == -1
-				    || ioctl (fd, HDIO_GETGEO, &geom)
-				    || ioctl (fd, BLKGETSIZE64, &length)) {
-                                        ped_exception_throw (
-                                                             PED_EXCEPTION_BUG,
-                                                             PED_EXCEPTION_CANCEL,
-			    _("Unable to determine the size and length of %s."),
-                                                             dev_name);
-                                        if (fd != -1)
-                                                close (fd);
-                                        free (dev_name);
+                                if (!_kernel_get_partition_start_and_length(part,
+                                                                &start, &length))
                                         goto cleanup;
-                                }
-                                free (dev_name);
-                                length /= disk->dev->sector_size;
-                                close (fd);
-                                if (geom.start == part->geom.start
+                                if (start == part->geom.start
 				    && length == part->geom.length)
                                         ok[i - 1] = 1;
                                 /* If the new partition is unchanged and the
diff --git a/parted/parted.c b/parted/parted.c
index 265282a..a5e2870 100644
--- a/parted/parted.c
+++ b/parted/parted.c
@@ -1398,7 +1398,7 @@ do_print (PedDevice** dev)
                                          "cpqarray", "file", "ataraid", "i2o",
                                          "ubd", "dasd", "viodasd", "sx8", "dm",
                                          "xvd", "sd/mmc", "virtblk", "aoe",
-                                         "md"};
+                                         "md", "loop"};
         char*           peek_word;
         char*           start;
         char*           end;
